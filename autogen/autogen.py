#!/usr/bin/env/python

""" autogen : This script is generated by Automatron """

__author__ = "John Doe"
__credits__ = ["John Doe"]
__version__ = "1.0.0"
__maintainer__ = "John Doe"
__email__ = "JohnDoe@gmail.com"
__status__ = "Prototype"

import os
import sys
import logging
import argparse
import yaml
import shutil
import subprocess
from datetime import datetime

JOB_NAME = 'autogen'
INPUT_DIR_NAME = 'input'
OUTPUT_DIR_NAME = 'output'
LOG_DIR_NAME = 'logs'
LOGGING_LOG_FORMAT = "%(asctime)s [ %(levelname)s ] : %(message)s"
LOGGING_DATE_FORMAT = "%Y%m%d %H:%M:%S"

CONFIG_FILE_NAME = 'config.yaml'
LOGGING_LEVEL = logging.DEBUG
CLI_ARGS = None
LOGGER = None
PROJECT_NAME = None

MODEL_FIELD_TEMPLATE = "{fieldName} = models.{fieldValue}\n    "

MODEL_TEMPLATE = """
class {modelName}(models.Models):
    '''
    This model is generated by Django-AutoGen 
    '''
    {modelFields}
    def __str__(self):
        return self.pk
"""

def assign_logging_from_config( logging_text ):
    """ Method to assign logging level from configurations """
    return {
        "DEBUG" : logging.DEBUG,
        "INFO" : logging.INFO,
        "WARN" : logging.WARN,
        "ERROR" : logging.ERROR,
        "CRITICAL" : logging.CRITICAL
    }.get( 
        logging_text, 
        logging.DEBUG 
    )

def init_configurations():
    """ Method to load configurations from primary config file """

    global CONFIG_FILE_NAME
    global LOGGING_LEVEL

    if CLI_ARGS.config:
        CONFIG_FILE_NAME = CLI_ARGS.config
    
    print( "Reading from %s"%( CONFIG_FILE_NAME ) )

    if not os.path.exists( CONFIG_FILE_NAME ):
        print( "Configuration file not found! Exiting." )
        sys.exit( os.EX_NOINPUT )

    with open( CONFIG_FILE_NAME ) as config_file_obj:
        configuration = yaml.load( config_file_obj, Loader=yaml.FullLoader )

        LOGGING_LEVEL = assign_logging_from_config( configuration['logging'] )

def generate_log_file_name():
    """ Method to generate new log file name with timestamp """
    return "".join( [ 
        JOB_NAME,
        '_',
        datetime.now().strftime('%Y%m%d%H%M%S'),
        '.log'
    ] )

def init_logging():
    """ Method to initialize logging configurations """

    global LOGGER

    LOGGER = logging.getLogger( "Logger" )
    LOGGER.setLevel( LOGGING_LEVEL )

    formatter = logging.Formatter( LOGGING_LOG_FORMAT, LOGGING_DATE_FORMAT )

    fileHandler = logging.FileHandler( os.path.join( LOG_DIR_NAME, generate_log_file_name() ) )
    fileHandler.setLevel( LOGGING_LEVEL )
    fileHandler.setFormatter( formatter )

    streamHandler = logging.StreamHandler()
    streamHandler.setLevel( LOGGING_LEVEL )
    streamHandler.setFormatter( formatter )

    LOGGER.addHandler( fileHandler )
    LOGGER.addHandler( streamHandler )

def init_argument_parsing():
    """ Method to initialize command line argument configurations """
    global CLI_ARGS
    argument_parser = argparse.ArgumentParser()
    argument_parser.add_argument( "-c", "--config", help="To provide runtime configuration file" )
    argument_parser.add_argument( "-d", "--create", help="To provide runtime configuration file" )
    CLI_ARGS = argument_parser.parse_args()

def init_directories():
    """ Method to initialize work directories if not exists """
    if not os.path.exists( INPUT_DIR_NAME ):
        os.mkdir( INPUT_DIR_NAME )
    if not os.path.exists( OUTPUT_DIR_NAME ):
        os.mkdir( OUTPUT_DIR_NAME )
    if not os.path.exists( LOG_DIR_NAME ):
        os.mkdir( LOG_DIR_NAME )

def initialize():
    """ Initializer method : To initialize objects """
    init_directories()
    init_argument_parsing()
    init_configurations()
    init_logging()

    cleanUpOutputDir()

    LOGGER.info( f"Initialization finished for Job : {JOB_NAME}" )

def generateProjectAndApps(PROJECT_NAME, APP_LIST):
    """ This method will generate the Django project along with the applications """
    django_start_project = ["django-admin","startproject",PROJECT_NAME,'.']
    django_start_app = ["python", "manage.py", "startapp"]
    LOGGER.info( f"Command to create project : {' '.join(django_start_project)}" )
    
    # Changing current directory to output dir
    PROJECT_DIR = os.path.join(OUTPUT_DIR_NAME, PROJECT_NAME)
    os.mkdir( PROJECT_DIR )
    os.chdir( PROJECT_DIR )
    
    subprocess.Popen(django_start_project).wait()
    for app in APP_LIST:
        command_param = [app]
        LOGGER.info( f"Command to create apps : {' '.join(django_start_app+command_param)}" )
        subprocess.run(django_start_app + command_param)

def generateModelField(modelInfo):
    """ Read the modelInfo map and create modelFields for the Model template """
    resultModelFields = ""
    for key in modelInfo:
        resultModelFields+=MODEL_FIELD_TEMPLATE.format(fieldName=key, fieldValue=modelInfo[key])
    return resultModelFields

def generateModel(fileName, modelName, modelInfo):
    """ For a target file, generate the model from given model Info """
    LOGGER.info( f"ModelInfo : {modelInfo}" )
    modelFields = generateModelField(modelInfo)
    modelTemplate = MODEL_TEMPLATE.format(modelName=modelName, modelFields=modelFields)
    with open(fileName, 'a') as modelFileObj:
        modelFileObj.write(modelTemplate)
    LOGGER.info( f"Generated model {modelName} : \n{modelTemplate}" )

def generateModelsForApp(appName, modelsMap):
    """ Generate the models from configuration read """
    LOGGER.info( f"Generating models for app : {appName}" )
    outputFile = os.path.join(appName, 'models.py')
    for model in modelsMap:
        generateModel(outputFile, model, modelsMap[model])

def execute():
    """ Execute method : To contain the main logic """

    global PROJECT_NAME

    LOGGER.debug( "Entering execute method." )

    # Read input file
    inputFileContent = read_input_file_content( 'book_app.yaml' )
    LOGGER.debug( f"Input file content : {inputFileContent}" )

    PROJECT_NAME = inputFileContent['project']
    APP_LIST = inputFileContent['apps']

    generateProjectAndApps(PROJECT_NAME, APP_LIST)
    
    for app in APP_LIST:
        if app in inputFileContent.keys():
            modelInfo = inputFileContent[app]['models']
            generateModelsForApp(app, modelInfo)

    LOGGER.debug( "Exiting execute method." )

def finalize():
    """ Finalizer method : To gracefully close connections """
    LOGGER.debug( "Entering finalizer method." )
    LOGGER.debug( "Exiting finalizer method." )


def read_input_file_content( fileName ):
    """ Will read and return the input file content, if the file exists """
    filePathWithName = os.path.join(INPUT_DIR_NAME,fileName)
    if os.path.exists( filePathWithName ):
        LOGGER.info( f"Found input file : {fileName}" )
        with open( filePathWithName, 'r' ) as fileObj:
            return yaml.safe_load(fileObj)

def cleanUpOutputDir():
    """ Performs the cleanup in output directory """
    folder = OUTPUT_DIR_NAME
    for fileName in os.listdir(folder):
        filePath = os.path.join(folder, fileName)
        try:
            if os.path.isdir(filePath):
                shutil.rmtree(filePath)
            elif os.path.exists(filePath):
                os.remove(filePath)
        except Exception as e:
            LOGGER.error( f"Failed to delete : {filePath} due to {e}" )

if __name__ == "__main__":

    initialize()
    execute()
    finalize()
