#!/usr/bin/env/python

""" autogen : This script is generated by Automatron """

__author__ = "John Doe"
__credits__ = ["John Doe"]
__version__ = "1.0.0"
__maintainer__ = "John Doe"
__email__ = "JohnDoe@gmail.com"
__status__ = "Prototype"

import os
import sys
import logging
import argparse
import yaml
import shutil
import subprocess
from datetime import datetime

from modelGenerator import utilities as mgutil
from viewGenerator import utilities as vgutil
from urlGenerator import utilities as ugutil
from templateGenerator import utilities as tgutil
from autogenUtilities.GenFileHandler import GenFile
from constants import common


JOB_NAME = 'autogen'
INPUT_DIR_NAME = 'input'
OUTPUT_DIR_NAME = 'output'
LOG_DIR_NAME = 'logs'
LOGGING_LOG_FORMAT = "%(asctime)s [ %(levelname)s ] : %(message)s"
LOGGING_DATE_FORMAT = "%Y%m%d %H:%M:%S"

CONFIG_FILE_NAME = 'config.yaml'
LOGGING_LEVEL = logging.DEBUG
CLI_ARGS = None
LOGGER = None
PROJECT_NAME = None

GEN_FILE = None

def assign_logging_from_config( logging_text ):
    """ Method to assign logging level from configurations """
    return {
        "DEBUG" : logging.DEBUG,
        "INFO" : logging.INFO,
        "WARN" : logging.WARN,
        "ERROR" : logging.ERROR,
        "CRITICAL" : logging.CRITICAL
    }.get( 
        logging_text, 
        logging.DEBUG 
    )

def init_configurations():
    """ Method to load configurations from primary config file """

    global CONFIG_FILE_NAME
    global LOGGING_LEVEL

    if CLI_ARGS.config:
        CONFIG_FILE_NAME = CLI_ARGS.config
    
    print( "Reading from %s"%( CONFIG_FILE_NAME ) )

    if not os.path.exists( CONFIG_FILE_NAME ):
        print( "Configuration file not found! Exiting." )
        sys.exit( os.EX_NOINPUT )

    with open( CONFIG_FILE_NAME ) as config_file_obj:
        configuration = yaml.load( config_file_obj, Loader=yaml.FullLoader )

        LOGGING_LEVEL = assign_logging_from_config( configuration['logging'] )

def generate_log_file_name():
    """ Method to generate new log file name with timestamp """
    return "".join( [ 
        JOB_NAME,
        '_',
        datetime.now().strftime('%Y%m%d%H%M%S'),
        '.log'
    ] )

def init_logging():
    """ Method to initialize logging configurations """

    global LOGGER

    LOGGER = logging.getLogger( "Logger" )
    LOGGER.setLevel( LOGGING_LEVEL )

    formatter = logging.Formatter( LOGGING_LOG_FORMAT, LOGGING_DATE_FORMAT )

    fileHandler = logging.FileHandler( os.path.join( LOG_DIR_NAME, generate_log_file_name() ) )
    fileHandler.setLevel( LOGGING_LEVEL )
    fileHandler.setFormatter( formatter )

    streamHandler = logging.StreamHandler()
    streamHandler.setLevel( LOGGING_LEVEL )
    streamHandler.setFormatter( formatter )

    LOGGER.addHandler( fileHandler )
    LOGGER.addHandler( streamHandler )

def init_argument_parsing():
    """ Method to initialize command line argument configurations """
    global CLI_ARGS
    argument_parser = argparse.ArgumentParser()
    argument_parser.add_argument( "-c", "--config", help="To provide runtime configuration file" )
    argument_parser.add_argument( "-d", "--create", help="To provide runtime configuration file" )
    CLI_ARGS = argument_parser.parse_args()

def init_directories():
    """ Method to initialize work directories if not exists """
    if not os.path.exists( INPUT_DIR_NAME ):
        os.mkdir( INPUT_DIR_NAME )
    if not os.path.exists( OUTPUT_DIR_NAME ):
        os.mkdir( OUTPUT_DIR_NAME )
    if not os.path.exists( LOG_DIR_NAME ):
        os.mkdir( LOG_DIR_NAME )

def initialize():
    """ Initializer method : To initialize objects """
    init_directories()
    init_argument_parsing()
    init_configurations()
    init_logging()

    cleanUpOutputDir()

    LOGGER.info( f"Initialization finished for Job : {JOB_NAME}" )

def generateProjectAndApps(PROJECT_NAME, APP_LIST):
    """ This method will generate the Django project along with the applications """
    django_start_project = ["django-admin","startproject",PROJECT_NAME,'.']
    django_start_app = ["python", "manage.py", "startapp"]
    LOGGER.info( f"Command to create project : {' '.join(django_start_project)}" )
    
    # Changing current directory to output dir
    PROJECT_DIR = os.path.join(OUTPUT_DIR_NAME, PROJECT_NAME)
    os.mkdir( PROJECT_DIR )
    os.chdir( PROJECT_DIR )
    
    subprocess.Popen(django_start_project).wait()
    for app in APP_LIST:
        command_param = [app]
        LOGGER.info( f"Command to create apps : {' '.join(django_start_app+command_param)}" )
        subprocess.run(django_start_app + command_param)


def generateModelsForApp(appName, modelsMap):
    """ Generate the models from configuration read """
    mgutil.addImportsToAdmin(appName)
    for modelName, modelFieldMap in modelsMap.items():
        LOGGER.info( f"Generating model : {modelName} for app : {appName}" )
        modelFields = mgutil.generateModelFields(modelFieldMap)
        modelSnippet = mgutil.generateModel(modelName, modelFields)
        LOGGER.debug( f"Model to be added : \n{modelSnippet}" )
        mgutil.addModelToFile(appName, modelSnippet)
        mgutil.addModelToAdmin(appName, modelName)


def generateViewsForApp(appName, modelsMap, viewsInfo):
    """ Generate the views from configuration read """
    vgutil.addAllImportsToFile(appName, viewsInfo)
    for modelName, modelFieldMap in modelsMap.items():
        if modelName in viewsInfo:
            viewsList = viewsInfo[modelName]
            LOGGER.info( f"Generating {viewsList} views for {modelName}" )
            viewsSnippet = vgutil.generateViewsForModel(appName, modelName, modelFieldMap, viewsList)
            LOGGER.debug( f"Views to be added : \n{viewsSnippet}" )
            vgutil.addViewsToFile(appName, viewsSnippet)


def generateUrlsForApp(appName, viewsInfo):
    """ Generate the urls from configuration read """
    ugutil.addContentToFile(appName, ugutil.generateImports(appName))
    urlPatterns = ugutil.generateUrlPatterns(viewsInfo)
    LOGGER.debug( f"Url Patterns generated for App : {appName}\n{urlPatterns}" )
    ugutil.addContentToFile(appName, urlPatterns)


def generateTemplatesForApp(appName, viewsInfo):
    """ Generate all the snippets with template names """
    LOGGER.debug( f"Generating templates for App : {appName} for views : {viewsInfo}" )
    tgutil.generateTemplateForViews(appName, viewsInfo)


def execute():
    """ Execute method : To contain the main logic """

    global PROJECT_NAME
    global GEN_FILE

    LOGGER.debug( "Entering execute method." )

    # Read input file
    inputFileName = os.path.join(common.INPUT_DIR_NAME, 'book_app.yaml')
    GEN_FILE = GenFile(inputFileName)

    PROJECT_NAME = GEN_FILE.getProjectName()
    APP_LIST = GEN_FILE.getAppList()

    generateProjectAndApps(PROJECT_NAME, APP_LIST)
    
    for appName in APP_LIST:
        modelInfo = GEN_FILE.getModels(appName)
        viewsInfo = GEN_FILE.getViews(appName)
        LOGGER.debug( f"Processing modelInfo from GenFile : {modelInfo}" )
        generateModelsForApp(appName, modelInfo)
        LOGGER.debug( f"Processing viewsList from GenFile : {viewsInfo}" )
        generateViewsForApp(appName, modelInfo, viewsInfo)
        generateUrlsForApp(appName, viewsInfo)
        generateTemplatesForApp(appName, viewsInfo)

    LOGGER.debug( "Exiting execute method." )


def finalize():
    """ Finalizer method : To gracefully close connections """
    LOGGER.debug( "Entering finalizer method." )
    LOGGER.debug( "Exiting finalizer method." )


def cleanUpOutputDir():
    """ Performs the cleanup in output directory """
    folder = OUTPUT_DIR_NAME
    for fileName in os.listdir(folder):
        filePath = os.path.join(folder, fileName)
        try:
            if os.path.isdir(filePath):
                shutil.rmtree(filePath)
            elif os.path.exists(filePath):
                os.remove(filePath)
        except Exception as e:
            LOGGER.error( f"Failed to delete : {filePath} due to {e}" )

if __name__ == "__main__":

    initialize()
    execute()
    finalize()
